## 1. Chrome架构

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。下面我们来逐个分析下这几个进程的功能。

- 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- GPU 进程。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

解决了单核浏览器哪些问题：

1. 不稳定：由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面
2. 不流畅：JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。
3. 内存泄漏：对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。
4. 安全：采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。

## 2. 从输入URL到页面展示，这中间发生了什么？

1. 用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL 
2.  用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得 
3. 浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 
4. 网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程 
5. 网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。 
6. Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。 
7. TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输 
8. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层 
9. 底层通过物理网络传输给目的服务器主机 
10. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 
11. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 
12. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 
13. 数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive  
14. 网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 
15. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程 
16. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 
17. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 
18. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来

## 3. 浏览器渲染流程   HTML、CSS和JavaScript是如何变成页面的

#### 1. 浏览器接收请求并获取资源

当用户输入 URL 或点击链接时，浏览器通过 HTTP 请求从服务器获取 HTML 文件。服务器响应后，浏览器开始下载 HTML，并根据 HTML 中的链接（如 <link> 或 <script>）加载 CSS、JavaScript 和其他资源（如图片）。这一阶段通常涉及网络层处理，确保资源按顺序或异步加载。

#### 2. 解析 HTML（构建 DOM 树）

- **解析过程**：浏览器接收到 HTML 后，解析 HTML 代码，将其分解为 Token（如开始标签、结束标签、属性、文本）。这些 Token 被组织成树形结构，称为 **文档对象模型（DOM）**。DOM 树的根节点通常是 <html> 标签，子节点包括 <head>、<body> 等。
- 特点：
  - HTML 解析是自顶向下的，逐步构建 DOM 树。
  - 如果遇到 <script> 标签且未设置 async 或 defer，浏览器会暂停 HTML 解析，转而执行 JavaScript，这可能延迟页面渲染。
  - 解析过程中，浏览器会同时处理外部资源（如 CSS 文件），但不会阻塞 HTML 解析本身。
- **性能影响**：大型 DOM 树会增加构建时间，影响首次渲染速度。研究表明，优化 HTML 结构（如减少嵌套深度）有助于提升性能。

#### 3. 解析 CSS（构建 CSSOM 树）

- **解析过程**：浏览器解析 CSS 代码，包括外部 CSS 文件（通过 <link> 标签）、内联样式和 <style> 标签中的样式。CSS 被分解为规则和选择器，构建 **CSS 对象模型（CSSOM）**，这是一个树形结构，包含所有 CSS 规则及其优先级。
- 特点：
  - CSS 解析不会阻塞 HTML 解析，但如果 JavaScript 需要访问 CSS 属性（如 window.getComputedStyle），则 CSSOM 的构建会阻塞 JavaScript 执行。
  - CSSOM 的构建速度较快，但复杂的 CSS 规则（如大量选择器或嵌套）可能会增加解析时间。
  - 浏览器会应用 CSS 级联规则，计算每个元素的最终样式，考虑继承和优先级。
- **性能优化**：建议将关键 CSS 放入初始 14KB 数据包中，以加速首次渲染。

#### 4. 构建渲染树（Render Tree）

- **构建过程**：一旦 DOM 和 CSSOM 准备就绪，浏览器将它们结合，生成 **渲染树（Render Tree）**。渲染树只包含需要显示的节点（例如，display: none 的元素不会被包含），每个节点都包含一个 DOM 元素及其对应的 CSS 样式。
- 特点：
  - 浏览器遍历 DOM 树，对于每个可见节点，查找 CSSOM 中匹配的样式规则。
  - 计算每个节点的最终样式，考虑 CSS 级联和继承。
  - 渲染树是后续布局和绘制的蓝图，确保只处理可见内容。
- **性能影响**：复杂的 DOM 和 CSSOM 可能增加渲染树构建时间，建议减少不必要的样式规则。

#### 5. 布局（Layout）

- **布局过程**：浏览器根据渲染树计算每个元素在页面上的位置和大小。布局阶段考虑 CSS 属性（如 position、float、margin、padding）以及视口大小和设备分辨率。
- 特点：
  - 布局是递归的，因为某些元素（如浮动元素）可能会影响其他元素的位置。
  - 如果页面结构或样式发生变化（如窗口调整大小、动态添加元素），浏览器会重新执行布局，称为 **重排（Reflow）**。
  - 布局阶段会受到设备特性的影响，如高分辨率屏幕（如 iPad 的 2048x1536，超过 314.5万像素）对性能要求更高。
- **性能优化**：避免频繁触发重排，例如一次性批量修改 DOM，而不是逐个修改。

#### 6. 绘制（Painting）

- **绘制过程**：浏览器遍历渲染树，根据每个节点的样式（如颜色、背景、边框）生成像素，将元素绘制到屏幕上。
- 特点：
  - 绘制阶段处理视觉效果，如阴影、渐变、透明度。
  - 绘制是分层的，复杂的页面可能有多个绘制层（如背景、前景、文本）。
  - 浏览器会优化绘制过程，使用 GPU 加速提高性能。
  - 如果只改变了样式（如背景颜色），浏览器会执行 **重绘（Repaint）**，而不需要重新布局。
- **性能影响**：频繁的重绘会增加 CPU 负载，建议使用 CSS 属性如 will-change 提示浏览器优化。

#### 7. 合成（Compositing）

- **合成过程**：如果页面有多个绘制层（如由于 CSS transform 或 opacity 导致的层叠），浏览器会将这些层合成为一个最终图像。
- 特点：
  - 合成阶段优化了性能，因为它允许独立更新和重绘不同的层。
  - 合成层被转换为屏幕上的像素（光栅化），确保最终显示效果。
- **性能优化**：使用硬件加速（如 CSS transform: translateZ(0)）可以提升合成效率。

#### 8. JavaScript 的执行

- **执行过程**：JavaScript 可以在任何阶段执行，例如通过 <script> 标签加载、用户交互或定时器触发。
- 影响：
  - JavaScript 可以动态修改 DOM、CSSOM 或渲染树，触发重排或重绘。
  - 如果 JavaScript 执行阻塞主线程（如未设置 async 或 defer 的脚本），会延迟页面渲染。
  - 例如，一个 2MB 的 JavaScript 文件可能占用主线程 1.5 秒，导致页面对点击或触摸无响应。
- 优化：
  - 使用 async 或 defer 属性减少 JavaScript 对渲染的阻塞。
  - 浏览器支持多线程（如 Web Workers），将非 UI 相关任务移出主线程。
  - 建议缓存 DOM 操作，减少频繁的 DOM 修改。

#### 9. 性能优化与关键渲染路径

- **关键渲染路径**：指从接收 HTML 到首次渲染页面的过程，包括解析 HTML、构建 DOM、解析 CSS、构建 CSSOM、生成渲染树、布局、绘制。
- 性能要求：
  - 整个过程必须在 16.67ms 内完成（对应 60fps），以确保平滑的滚动和动画。
  - 高分辨率屏幕对性能要求更高，需优化资源加载和渲染。
- 优化策略：
  - 将关键 CSS 和 HTML 放入初始 14KB 数据包中，加速首次渲染。
  - 减少复杂的 CSS 和 JavaScript，降低解析和执行时间。
  - 使用工具如 Lighthouse 分析性能瓶颈。

#### 总结与建议

浏览器渲染流程是一个高度优化的过程，确保页面快速加载和响应。理解这些步骤有助于开发者优化网站性能，减少重排和重绘的开销，提高用户体验。建议关注关键渲染路径，优化 JavaScript 执行和 CSS 加载，以提升页面加载速度和交互响应。

以下表格总结了各阶段的主要任务和性能影响：

| **阶段**        | **主要任务**                   | **性能影响**              |
| --------------- | ------------------------------ | ------------------------- |
| 解析 HTML       | 构建 DOM 树                    | 大型 DOM 树增加构建时间   |
| 解析 CSS        | 构建 CSSOM 树                  | 复杂 CSS 规则增加解析时间 |
| 构建渲染树      | 结合 DOM 和 CSSOM              | 复杂结构可能延缓渲染      |
| 布局            | 计算位置和大小                 | 触发重排影响性能          |
| 绘制            | 将元素绘制到屏幕               | 频繁重绘增加 CPU 负载     |
| 合成            | 合并多层为最终图像             | 优化后提升硬件加速效率    |
| JavaScript 执行 | 修改 DOM/CSSOM，触发重排或重绘 | 阻塞主线程影响交互响应    |

## 4. JavaScript 垃圾回收机制详解

### 1. 概述

JavaScript 是一种动态语言，开发者无需手动分配或释放内存。JavaScript 引擎通过垃圾回收机制自动检测和回收不再使用的对象（称为“垃圾”），从而释放内存。这种机制对于防止内存泄漏和优化应用程序性能至关重要。

垃圾回收的核心任务是：

- **识别垃圾**：确定哪些内存块不再被程序引用。
- **回收内存**：释放这些内存块，供后续使用。

### 2. 垃圾回收的基本原理

JavaScript 中的垃圾回收基于以下核心概念：

- **内存分配**：当创建变量、对象、数组或函数时，JavaScript 引擎会在堆内存中分配空间。
- **引用关系**：对象通过引用（如变量、属性）相互关联，形成一个引用图。
- **垃圾定义**：如果某个对象不再被任何活动对象引用（不可达），则被视为垃圾，可以回收。

垃圾回收的目标是定期扫描内存，回收不可达对象，释放堆内存空间。

### 3. 主要垃圾回收算法

JavaScript 引擎通常使用以下算法来实现垃圾回收，现代引擎（如V8）结合多种算法以优化性能。

#### 3.1 标记-清除（Mark-and-Sweep）

这是 JavaScript 中最常用的垃圾回收算法，分为两个阶段：

- **标记阶段**：从根对象（如全局对象 `window` 或 `global`、当前调用栈中的变量等）开始，递归遍历所有可达对象，标记为“活动”。

- **清除阶段**：扫描堆内存，回收未被标记的对象，释放其内存空间。

- 优点：

  - 能有效回收循环引用的对象（例如，两个对象互相引用但不再被根引用）。
  - 实现简单，适用于大多数场景。

- 缺点：

  - 内存碎片化：回收后可能导致内存不连续，影响大对象分配。
  - 暂停式执行：垃圾回收期间会暂停 JavaScript 执行（称为“Stop-the-World”），可能导致性能瓶颈。

- 示例：

  ```javascript
  let obj = { a: 1 };
  obj = null; // obj 失去引用，成为垃圾
  // 标记-清除算法会在下次 GC 时回收 obj
  ```

#### 3.2 引用计数（Reference Counting）

- **原理**：跟踪每个对象的引用计数。当引用计数为 0 时，对象被视为垃圾并立即回收。

- **优点**：回收及时，内存释放较快。

- 缺点：

  - **循环引用问题**：如果两个对象互相引用，即使它们不再被其他对象使用，引用计数也不会为 0，导致内存无法回收。

  - 示例：

    ```javascript
    function createCycle() {
      let obj1 = {};
      let obj2 = {};
      obj1.ref = obj2;
      obj2.ref = obj1; // 循环引用
    }
    createCycle(); // 即使函数执行完毕，obj1 和 obj2 不会被回收
    ```

  - 现代 JavaScript 引擎已较少单独使用引用计数，通常结合标记-清除解决循环引用问题。

#### 3.3 分代回收（Generational Collection）

- 原理：现代 JavaScript 引擎（如 V8）将对象分为“新生代”和“老生代”，基于“大多数对象生命周期短”的假设：

  - **新生代**：新创建的对象，生命周期较短，回收频率高，使用快速的 **Scavenge 算法**。
  - **老生代**：存活时间较长的对象，回收频率低，使用标记-清除或标记-压缩（Mark-Compact）。

- 过程：

  - 新生代对象分配在较小的内存区域，频繁进行小型垃圾回收（Minor GC）。
  - 存活多次回收的对象晋升到老生代，定期进行大型垃圾回收（Major GC）。

- 优点：

  - 提高回收效率，减少对老生代对象的频繁扫描。
  - 减少 Stop-the-World 时间，优化性能。

- 示例：

  ```javascript
  function createObjects() {
    let temp = new Array(1000); // 分配在新生代
    // 短生命周期对象可能在下次 Minor GC 被回收
  }
  let longLived = []; // 存活时间长，可能晋升到老生代
  ```

#### 3.4 增量回收（Incremental GC）

- **原理**：将垃圾回收分成多个小步骤，穿插在 JavaScript 执行之间，减少单次暂停时间。
- **优点**：降低 Stop-the-World 的影响，提升交互性能，适合实时性要求高的应用（如游戏）。
- **缺点**：实现复杂，可能增加总体回收时间。

#### 3.5 标记-压缩（Mark-Compact）

- **原理**：在标记-清除的基础上，将存活对象移动到内存的一端，消除碎片化。
- **优点**：解决内存碎片问题，适合老生代回收。
- **缺点**：移动对象增加开销，暂停时间可能较长。

### 4. V8 引擎的垃圾回收优化

V8 引擎（用于 Chrome 和 Node.js）是 JavaScript 垃圾回收的典型实现，结合了多种技术：

- Orinoco 项目：V8 引入了增量回收、并行回收和并发回收：

  - **并行回收**：利用多线程并行执行垃圾回收任务。
  - **并发回收**：允许垃圾回收与 JavaScript 主线程同时运行。
  
- 新生代 Scavenge 算法：

  - 使用 Cheney 算法，将新生代分为两个半空间（From 和 To）。
  - 存活对象从 From 空间复制到 To 空间，未存活对象被回收。
  - 快速高效，适合短生命周期对象。
  
- **老生代回收**：结合标记-清除和标记-压缩，定期清理长期存活对象。

- **Idle-time GC**：在浏览器空闲时执行垃圾回收，减少对用户交互的影响。

### 5. 垃圾回收的性能影响

- **Stop-the-World**：垃圾回收可能暂停 JavaScript 执行，导致页面卡顿，尤其在老生代回收时。

- **内存碎片**：频繁分配和回收可能导致内存不连续，影响大对象分配。

- 内存泄漏：某些模式可能导致对象未被回收，例如：

  - **全局变量**：未清理的全局变量（如 `window.myObj`）。
  - **闭包**：未释放的闭包引用。
  - **事件监听器**：未移除的监听器（如 `addEventListener` 未调用 `removeEventListener`）。
  
- 示例：

  ```javascript
  function leak() {
    let obj = {};
    window.leakRef = obj; // 全局引用导致内存泄漏
  }
  ```

### 6. 优化垃圾回收的建议

为减少垃圾回收的开销和内存泄漏，开发者可以采取以下措施：

- 减少对象分配：

  - 复用对象，避免频繁创建临时对象。
  - 示例：使用对象池（Object Pooling）管理临时对象。

- 及时解除引用：

  - 将不再使用的变量赋值为 `null`。
  - 示例：`let temp = largeObject; temp = null;`

- 移除事件监听器：

  - 在组件销毁时移除监听器。
  - 示例：`element.removeEventListener('click', handler);`

- 避免全局变量：

  - 尽量使用局部变量，减少长期引用。

- 优化闭包：

  - 确保闭包中的变量在不需要时被释放。

  - 示例：

    ```javascript
    function createClosure() {
      let data = new Array(1000);
      return function() {
        console.log(data.length);
      };
    }
    // data 可能长期存活，需注意释放
    ```

- 使用 WeakMap 和 WeakSet：

  - 这些结构允许键或值被垃圾回收，适合临时引用。

  - 示例：

    ```javascript
    let weakMap = new WeakMap();
    let obj = {};
    weakMap.set(obj, 'data');
    obj = null; // obj 可被回收
    ```

### 7. 调试和监控垃圾回收

- Chrome DevTools：

  - 使用“Performance”面板记录垃圾回收事件，查看 Stop-the-World 时间。
  - 使用“Memory”面板检测内存泄漏，分析堆快照（Heap Snapshot）。

- Node.js：

  - 使用 `--trace-gc` 查看垃圾回收日志。
  - 使用 `process.memoryUsage()` 监控内存使用情况。

- 示例：

  ```javascript
  console.log(process.memoryUsage());
  // 输出：{ heapTotal, heapUsed, external, ... }
  ```

### 8. 总结

JavaScript 的垃圾回收机制通过标记-清除、分代回收等算法自动管理内存，优化了开发体验，但也带来性能挑战。开发者需理解其原理，采取优化措施（如减少对象分配、避免内存泄漏），以提升应用性能。现代引擎通过增量回收、并行回收等技术显著减少了暂停时间，但仍需注意复杂场景下的内存管理。